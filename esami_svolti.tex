\section{Esami svolti}
In questa sezione sono raccolti alcune tracce degli esami della professoressa
Moscardini con soluzioni. Tali soluzioni sono state elaborate con diversi studenti
e basate anche sulla correzione di alcuni esercizi della professoressa in aula e 
in sede di revivisione del compito. Prima di elencare tali soluzioni, vediamo quali
sono le tecniche per risolvere i principali e ricorrenti quesiti presenti in sede d'esame.\\
\textbf{NOTA}: le tracce dei compiti sono sempre le stesse da almeno un paio di anni, ma non
si può garantire che resteranno uguali negli anni a venire. Ciò non toglie che tali esercizi 
siano fondamentali per questo esame.
\subsection{Tecniche risolutive}
Il compito sarà diviso in tre parti:
\begin{enumerate}
 \item \textbf {Algebra relazionale}: vi verrà chiesto di esprimere in tale linguaggio
 un'interrogazione ad un database per ottenere particolari informazioni. Su questa prima parte
 non c'è molto da dire, si applicano semplicemente i vari operatori a seconda della richiesta; 
 si useranno in congiunzione la \emph{proiezione}, \emph{la selezione} e il \textbf{join}. 
 Vi verranno date tipicamente tre relazioni: il pattern che si ripete
 è che due relazioni non hanno nessun attributo in comune e rappresentano due ``realtà 
 disgiunte'', mentre la terza ha due attributi (oltre a diversi altri) che rimandano alle chiavi 
 delle altre due tabelle. In questo modo è possibile mettere tutte e tre in relazione con il join 
 (impostando tali attributi in comune come ``$\Theta$ del join''). La seconda espressione algebrica
 vi chiede di solito di ritornare una relazione contenente elementi che \emph{non} hanno una 
 determinata caratteristica (es: tutti i musei a Roma che non hanno opere di Picasso); i dati e il 
 testo dell'esercizio vi vogliono mettere in condizione di dover usare \textbf{l'operatore differenza},
 ovvero bisogna trovare prima tutti gli elementi che presentano tale proprietà per poi sottrarli 
 all'insieme di tutti gli elementi (di una stessa relazione s'instende). Vedremo negli esercizi 
 svolti degli esempi che chiariranno le idee.
 \item \textbf {Terza forma normale}: il secondo esercizio chiede essenzialmente di applicare 
 alcuni dei cinque algoritmi visti nella \textsc{Sezione 4} di questa dispensa per verificare 
 delle proprietà. Tipica richiesta è dimostrare che un dato insieme di attributi è chiave per R, 
 oppure vi sarà chiesto di trovare una scomposizione che preservi un insieme di dipendenze. Le 
 tecniche per risolvere questo tipo di esercizi sono ampiemente illustrate nei vari esempi nella 
 sezione apposita, quindi non le ripeteremo qui. Unica nota è che quando vi si chiede se la 
 relazione è in \emph{3NF} è consigliato utilizzare la \textsc{Definizione 4.6}.
 \item \textbf{Organizzazione fisica}: con la terza parte vuole si vuole testare se lo studente ha
 assimilato in maniera adeguata i modi in cui può ossere organizzato fisicamente il database, quindi 
 si consiglia di studiare bene la \textsc{Sezione 5}. Spiegheremo più a fondo questo esercizio nel 
 prossimo paragrafo.
\end{enumerate}

\subsubsection{Risoluzione Esercizio 3: ``blocchi necessari per..''}
Questo esercizio si suddivide (solitamente) in tre punti, ciascuno dei quali vi chiede
\begin{enumerate}
\item Quanti blocchi dobbiamo utilizzare per il file principale? 
\item Quanti blocchi dobbiamo utilizzare per il file indice?
\item Qual è il costo per la ricerca di un record? 
\end{enumerate}

Per rispondere a queste domande bisogna conoscere alcuni dati, presenti nel testo dell'esercizio. Nella lista 
seguente saranno elencati tali dati, ed ognuno sarà indicato da un nome di variabile che sarà utilizzato nel 
descrivere le formule risolutive:

\begin{itemize}
 \item Numero di record nel file (principale)$[\mathbf{nRecord}]$: di solito è un numero nell'ordine delle centinaia 
 di migliaia;
 \item byte occupati da un singolo record$[\mathbf{btRecord}]$: viene specificato anche quanto è grande la \emph{chiave}$[\mathbf{btChiave}]$
 dato che servirà in un secondo momento;
 \item byte occupati da un blocco$[\mathbf{btBlocco}]$: viene specificato se, nel momento dell'inizializzazione, 
 il blocco deve essere riempito a pieno, a metà, al minimo o a una certa percentuale. Può capitare
 che i blocchi del file principale siano riempiti in un certo modo mentre quelli del file indice in 
 un altro;
 \item byte occupati da un puntatore ad un blocco $[\mathbf{btPuntatore}]$.
 \item \emph{tipo di organizzaizione} utilizzata dal file. \`E un dato essenziale per poter svolgere
 l'esercizio.
\end{itemize}
La tipologia dell'organizzazione è la prima informazione da prendere in considerazione, perché caratterizzerà
la risoluzione delle domande dell'esercizio. Il seguente paragrafo tratta la risoluzione di esercizi dove il file
è organizzato come \textbf{B-Tree} o \textbf{ISAM} (file a indice sparso). Una volta apprese le tecniche illustrate
per questi due tipi di file verrà affrontato l'argomento del file \textbf{Hash}, il quale presenta delle sostanziali
distinzioni per via della sua struttura.\\

\noindent\textbf{\fontsize{16pt}{1em}File B-Tree e ISAM}\\

\noindent\textbf{\fontsize{14pt}{1em}Domanda 1}\\
Si calcola prima il numero di record presenti in un blocco del file principale: tale numero è
\begin{center}
$RecBlocco = \Bigl\lfloor \dfrac{btBlocco}{btRecord} \Bigr\rfloor$
\end{center}
dove le $\bigl\lfloor X \bigr\rfloor$ indicano la parte intera inferiore di $X$ (esempio: $\bigl\lfloor 4,5 
\bigr\rfloor = 4$). Utilizzeremo anche la parte intera superiore di $\bigl\lceil X \bigr\rceil$ (esempio: $\bigl\lceil 4,5 
\bigr\rceil = 5$).\\

 Già a questo punto, al variare del tipo di organizzazione del file, variano alcuni dettagli della formula per il calcolo di
 $RecBlocco$.
 \begin{itemize}
  \item La formula enunciata prima è valida quando è richiesto che il blocco venga \textbf{riempito completamente} dai record e 
 l'organizzazione del file è il \emph{B-tree}.
 \item Se l'organizzazione è l'\emph{ISAM} (file a indice sparso) ed è richiesto che il blocco venga \textbf{riempito completamente} 
 dai record la formula diventa
  \begin{center}
  $RecBlocco = \Bigl\lceil \dfrac{btBlocco - btPuntatore}{btRecord} \Bigr\rceil$.
  \end{center}
  \item Con \emph{B-tree} o l'\emph{ISAM}, spesso è richiesto che il blocco sia \textbf{pieno fino ad una certa percentuale} $P$:
  sarà allora necessario prima calcolare il $P\%$ di $btBlocco$, che indicheremo con $PercBlocco$ = $(P \cdot btBlocco)/100$. Il numero
  di record in un blocco sarà
  \begin{center}
  $RecBlocco = \Bigl\lceil \dfrac{PercBlocco}{btRecord} \Bigr\rceil$.
  \end{center}
  Notiamo che si prende \emph{la parte superiore} del valore, visto che esso non può scendere sotto la data percentuale mentre, 
   dato che c'è dello spazio libero, il blocco può ``permettersi di ospitare'' un record in più\footnote{Si può riflettere sulla
  veridicità della proposizione attraverso la seguente analogia.
  Dobbiamo versare delle bottiglie di vino in una botte da 15 litri, la quale va riempita con almeno 11 litri. 
  Ogni bottiglia contiene 3,3 litri di vino ed è un'unità inscindibile (leggasi: non possiamo smezzare una bottiglia); quante bottiglie
  devo utilizzare? Per versare 11 litri nella botte abbiamo bisogno di $11/3,3=3,3$ bottiglie. A questo punto è evidente che 
  possiamo decidere di usare 4 bottiglie (analoga parte superiore) o usare 3 bottiglie (parte inferiore). Se decidiamo di versare 
  3 bottiglie non raggiungiamo la soglia degli $11$ litri (solo $9,9$). Scegliere di versare 4 bottiglie (ovvero 
  la parte superiore) per un totale di $13,2$ litri a botte, in questi casi è la cosa migliore.}.  
  \item Un caso particolare del punto 2 è quando l'organizzazione è il \emph{B-Tree} ed richiesto che il numero di record in un blocco
  sia il \textbf{minimo}. Il minimo di byte che posso mettere in un blocco di un B-tree è \emph{la metà} della sua capacità
  (per via della ricerca binaria), quindi si ha che
   \begin{center}
  $RecBlocco = \Bigl\lceil \dfrac{btBlocco}{2\cdot btRecord} \Bigr\rceil$.\\
  \end{center}
 \end{itemize}
 
  Una volta in possesso del valore $RecBlocco$ possiamo rispondere alla domanda 1 attraverso la formula
  \begin{center}
   $NumBlocchiFP = \Bigl\lceil\dfrac{nRecord}{RecBlocco}\Bigr\rceil$
  \end{center}
  dove $NumBlocchiFP$ è il numero di blocchi utilizzati nel file principale. Tale valore intero è dato \emph{sempre} dalla parte 
  superiore della frazione.\\
  
  \noindent\textbf{\fontsize{14pt}{1em}Domanda 2}\\
  Troviamo innanzitutto il numero di record per blocco che indicheremo con $RecBloccoI$, dove il suffisso ``$I$''
  ci ricorda che è un blocco dell'indice. 
  \begin{itemize}
   \item Per un \textbf{B-Tree}: un blocco del File Indice contiene un puntatore ad un altro blocco
  e lo spazio ($btPuntatore$) occupato da esso non può essere messo a disposizione dei record; tenendo a mente questo e che un record
  del File Indice è dato dalla coppia $(puntatore,\ chiave)$, abbiamo che
  \begin{center}
   $RecBloccoI = \Bigl\lfloor \dfrac{btBlocco - btPuntatore}{btPuntatore + btChiave}\Bigr\rfloor + 1$
  \end{center}
  Il +1 rappresenta quel record in più che contiene il puntatore al blocco contentente record che hanno chiave
  minore della sua chiave più piccola.
  \item per un \textbf{file ISAM} non va tolta la dimensione del puntatore né aggiunto il +1
  \begin{center}
   $RecBloccoI = \Bigl\lfloor \dfrac{btBlocco}{btPuntatore + btChiave}\Bigr\rfloor$
  \end{center}
  \end{itemize}
\`E da tenere a mente 
  che il discorso fatto per la domanda 1 è valido anche per la domanda 2, visto che stiamo calcolando
  sempre il numero di record in un blocco.\\
  Calcolato $RecBloccoI$ e ricordando che ogni blocco nel File Principale corrisponde a un record nel File Indice, il numero 
  dei blocchi nel File indice è:
  \begin{itemize}
   \item per un \textbf{file ISAM}, $NumBlocchiFI = \Bigl\lceil \dfrac{NumBlocchiFP}{RecBloccoI}\Bigr\rceil$;
   \item per un \textbf{file B-Tree}, il quale ha il File Indice organizzato come una gerarchia di indici,
   la somma dei valori che $NumBlocchiFI$ assume applicando la formula del punto precedente
   in modo ricorsivo, sostituendo ogni volta a NumBlocchiFP il valore trovato alla chiamata ricorsiva precedente, fino a quando
   $NumBlocchiFI < RecBloccoI$. Raggiunta questa condizione, il valore di quella formula è 1, ed è l'ultimo valore da sommare.
   Tale formula deriva dal fatto che ogni blocco di un certo livello è rappresentato da un record al livello piu alto.
  \end{itemize}
  
  \noindent\textbf{\fontsize{14pt}{1em}Domanda 3}\\
  Il costo della ricerca è misurato contando il numero di accessi a blocchi. In un \textbf{file ISAM} varia tra 2 e 
  $log_2(NumBlocchiFI) + 1$, per via della ricerca binaria (da 1 a $log_2(NumBlocchiFI)$) più un accesso ad un blocco
  nel File Principale. In un \textbf{file B-Tree} il costo della ricerca è dato dall'altezza dell'albero che rappresenta
  la gerarchia degli indici (che è uguale al numero di iterazioni della formula per calcolare il 
  numero di blocchi nel File Indice) più un accesso al blocco cercato nel File Principale.\\
  
  \noindent\textbf{\fontsize{16pt}{1em}File Hash}\\
  Per il file Hash valgono le suddette considerazioni, tenendo conto però che un file HASH ha i record distribuiti in egual misura
  in gruppi di blocchi chiamati bucket. I blocchi in un bucket sono organizzati come una \emph{linked list}, il primo blocco punta al
  secondo, il secondo al terzo e cosi via. Gli indirizzi dei primi blocchi dei bucket sono conservati in un file indice composto solo
  da puntatori. Detto ciò vogliamo rispondere alle seguenti domande: quanti blocchi di
  memoria occupa il file? Quale è il numero medio di accessi per ricercare un record del file?\\
  
Calcoliamo innanzitutto il numero di record per blocco richiesto per la directory; 
\begin{center}
 $puntatori \times blocco = \Bigl\lfloor \dfrac{btBlocco}{btPuntatore} \Bigr\rfloor$
\end{center}
quindi i blocchi richiesti dalla directory sono
\begin{center}
 $BlocchiDir = \Bigl\lceil \dfrac{totBucket}{puntatori \times blocco} \Bigr\rfloor$
\end{center}
Passiamo al file principale, diviso in bucket. Calcoliamo il numero di record per blocco
\begin{center}
 $RecBlocco = \Bigl\lfloor \dfrac{btBlocco-btPuntatore}{btRecord} \Bigr\rfloor$
\end{center}
I record totali devono essere ripartiti uniformemente nei bucket
\begin{center}
 $record \times bucket = \Bigl\lceil \dfrac{nRecord}{totBucket} \Bigr\rceil$
\end{center}
Ora il numero totale di blocchi nel file principale è dato dal numero di blocchi in un bucket
moltiplicato per il numero di bucket.
\begin{center}
 $BlocchiFP = \Bigl\lceil \dfrac{record \times bucket}{RecBlocco} \Bigr\rceil \cdot totBucket$
\end{center}
Quindi in totale il file occupa $BlocchiFP + BlocchiDir$. Il costo medio di 
una ricerca è dato da
\begin{center}
 $\Bigl\lceil \Bigl\lceil \dfrac{record \times bucket}{RecBlocco} \Bigr\rceil \cdot \dfrac{1}{2} \Bigr\rceil$
\end{center}
visto che si cerca dentro un solo bucket ed essendo il costo medio si suppone che il record
cercato sia a metà bucket.

  
  
  
  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  %%%%%%%%%%%%%%%%%%INIZIO ESAMI%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  \newpage
  \subsection{Esame 16/01/2013}
  \subsubsection{Esercizio 1}
  Dato il seguente schema di una base di dati contenente dati su corsi universitari, aule e orario delle lezioni:
  \begin{center}
  AULA(Id, Nome, N-posti, Edificio)\\
  CORSO(Id, Titolo, Anno, Docente) \\
  ORARIO(Id-Aula, GiornoSettimana, Fascia-oraria, Id-Corso)\\ 
  \end{center}
  esprimere in algebra relazionale le seguenti interrogazioni:
  \begin{enumerate}
   \item Si desidera conoscere quando e dove (cioè: giorno della settimana, fascia oraria, aula ed edificio in cui 
   si trova l'aula) si svolgono le lezioni di Basi di Dati tenute dal docente Moscarini.
   \item Dati delle aule in cui non si svolgono lezioni di corsi del I anno.
  \end{enumerate}
  \noindent\textbf{\fontsize{14pt}{1em}Soluzione.}\\
  Per sintetizzare la scrittura, altrimenti troppo lunga, assegneremo ad ogni attributo che verrà usato
  nell'espressione una lettera.
  
  \begin{multicols}{3}
  \begin{flushleft}
   $A = Orario.Id-Corso$\\
   $B = Orario.Id-Aula$\\
   $C = Orario.GiornoSettimana$\\
   $D = Orario.Fascia-oraria$\\
   $E = Corso.Id$\\
   $F = Corso.Titolo$\\
   $G = Corso.Anno$\\
   $H = Corso.Docente$\\
   $I = Aula.Id$\\
   $J = Aula.Nome$\\
   $K = Aula.N-posti$\\
   $L = Aula.Edificio$\\
  \end{flushleft}
  \end{multicols}

   \noindent(1) $\pi_{C, D, J, L}((AULA)\bowtie_{B=I}((\sigma_{F=``Basi\ di\ Dati'' \wedge H=``Moscardini''}(CORSO))\bowtie_{A=E}(ORARIO)))$\\
   (2) $\pi_{I, J, K, L}(AULA)-$ \\ $- \pi_{I, J, K, L}((AULA)\bowtie_{B=I}((\sigma_{G=1}(CORSO))\bowtie_{A=E}(ORARIO)))$\\

   Nel punto (2) prima si prendono le aule che ospitano corsi del primo anno, poi le sottraggo alla relazione che contiene tutte
   le aule. \textbf{IMPORTANTE:} per poter effettuare tale operazione, le due relazioni sulle quali agisce l'operatore devono avere
   lo stesso numero e corrispondente tipo di attributi. A tal fine, prima di effettuare la differenza, applichiamo la proiezione su 
   entrambi i membri per far coincidere gli attributi (che sono poi gli attributi da noi cercati).
  \subsubsection{Esercizio 2}
 Dati $R=ABCDEHI$ e $F=\{AB\rightarrow CD, B\rightarrow E, E\rightarrow AC, H\rightarrow B\}$
 \begin{itemize}
  \item Mostrare che $HI$ è una chiave di $R$;
  \item Sapendo che $HI$ è l'unica  chiave di $R$, mostrare che $R$ non è in terza forma normale;
  \item Trovare una decomposizione $\rho$ di $R$ tale che:
    \begin{itemize}
     \item ogni schema in $\rho$ è in terza forma normale
    \item $\rho$ preserva $F$
    \end{itemize}
 \end{itemize}
 
 \noindent\textbf{\fontsize{14pt}{1em}Soluzione.}\\
 $HI$ è chiave per $R$ $\Leftrightarrow HI \rightarrow R\in F^+ \Leftrightarrow R \subseteq (HI)^+_F \wedge
 R \not\subseteq (H)^+_F \wedge R \not\subseteq (I)^+_F$. Calcoliamo allora le suddette chiusure 
 e verifichiamo tali condizioni.\\\\
 $(HI)^+_F = HIBEACD \supseteq R$;\\
 $(H)^+_F = HBEACD \not\supseteq R$;\\
 $(I)^+_F = I \not\supseteq R$;\\\\
Quindi $HI$ è chiave per $R$. $R$ inoltre non è in terza forma normale perché prendendo certe dipendenze in $F$, ad esempio 
$B \rightarrow E$, si ha che $B$ non è superchiave ed $E$ non è primo; ciò va contro la definizione di schema in 3NF.\\
Per rispondere al terzo punto bisogna trovare la copertura minimale di $F$:
\begin{center}
 \begin{tabular}{l|l|l}
  $G$ & $G'$ & $G''$\\
  \hline
  $AB\rightarrow C$ & $B\rightarrow C$ & \textbackslash \\
  $AB \rightarrow D$ & $B \rightarrow D$ & $B \rightarrow D$\\
  $B \rightarrow E$ & $B \rightarrow E$ & $B \rightarrow E$\\ 
  $E \rightarrow A$ & $E \rightarrow A$ & $E \rightarrow A$\\
  $E \rightarrow C$ & $E \rightarrow C$ & $E \rightarrow C$\\
  $H \rightarrow B$ & $H \rightarrow B$ & $H \rightarrow B$\\ 
 \end{tabular}
\end{center}
Quindi si esegue l'algoritmo 4.5 ed esce $\rho= \{I, BD, BE, EA, EC, HB\}$.

\subsubsection{Esercizio 3}
Abbiamo un file di 288.000 record. Ogni record occupa 49 byte di cui 10 per la chiave. Ogni blocco contiene 2048 byte. 
Un puntatore a blocco occupa 4 byte. Usiamo una organizzazione B-tree riempiendo al minimo sia i blocchi del file 
principale che quelli del file indice.
\begin{enumerate}
 \item Quanti blocchi dobbiamo utilizzare per il file principale? 
 \item Quanti blocchi dobbiamo utilizzare per il file indice?
 \item Qual è il costo per la ricerca di un record? 
\end{enumerate}

\noindent\textbf{\fontsize{14pt}{1em}Soluzione.}\\
Come visto nel paragrafo Tecniche Risolutive, si calcola prima il numero di record per blocco. Il testo dice che 
ogni blocco è riempito al minimo, che in un B-Tree equivale a dire riempito a metà. Applichiamo la formula:
 \begin{center}
 $RecBlocco = \Bigl\lceil \dfrac{2048}{2\cdot 49} \Bigr\rceil = 21$.\\
\end{center}
Quindi calcoliamo il numero di blocchi nel file principale
\begin{center}
 $NumBlocchiFP = \Bigl\lceil \dfrac{288.000}{21} \Bigr\rceil = 13.715$.\\
\end{center}
Calcoliamo ora il numero di record in un blocco del file indice
\begin{center}
 $RecBloccoI = \Bigl\lceil \dfrac{1024-4}{10+4} \Bigr\rceil + 1 = 74$.\\
\end{center}
Il numero di blocchi nel file indice è dato dalla somma di questi tre valori:
\begin{center}
 Blocchi al livello I $= \Bigl\lceil \frac{13.715}{74} \Bigr\rceil = 186$.\\
 
 Blocchi al livello II $= \Bigl\lceil \frac{186}{74} \Bigr\rceil = 3$.\\
 
 Blocchi al livello III $= \Bigl\lceil \frac{3}{74} \Bigr\rceil = 1$.\\
 Totale = $190$.
\end{center}
Ne deriva che il costo di ricerca è dato da 3 (numero di livelli) + 1 (accesso al blocco nel File Principale).
\newpage
\subsection{Esame 10/06/2013}
  \subsubsection{Esercizio 1}
  Dato il seguente schema di una base di dati contenente dati relativi a musei:
  \begin{center}
  MUSEO (Codice, Nome, Indirizzo, Regione)\\
  PITTORE (Codice, Nome, Cognome, Soprannome, DataNascita, DataMorte)\\
  QUADRO (Codice, Titolo, Autore, Anno, Museo)\\
  \end{center}
  NOTE:\\
  L'attributo Codice è chiave per le relazioni\\
  L'attributo Autore nella tabella QUADRO è il codice dell'autore del quadro\\
  L'attributo Museo nella tabella QUADRO è il codice del museo in cui il quadro è conservato\\
  L'attributo Anno nella tabella QUADRO è l'anno di realizzazione dell'opera\\

  Esprimere in algebra relazionale le seguenti interrogazioni:
  \begin{enumerate}
   \item Quali quadri del Pinturicchio sono conservati nei musei della Toscana. Restituire come risultato titolo del quadro e 
   nome ed indirizzo del museo.
   \item In quali musei della Toscana non è conservato alcun quadro del XV secolo? Restituire come risultato nome e indirizzo del museo.   
  \end{enumerate}
  \noindent\textbf{\fontsize{14pt}{1em}Soluzione.}\\
  Per sintetizzare la scrittura, altrimenti troppo lunga, assegneremo ad ogni attributo che verrà usato
  nell'espressione una lettera.
  
  \begin{multicols}{3}
  \begin{flushleft}
   $A =Quadro.Autore$\\
   $B = Quadro.Museo$\\
   $C = Pittore.Codice$\\
   $D = Pittore.Soprannome$\\
   $E = Museo.Codice$\\
   $F = Museo.Regione$\\
   $G = Museo.Nome$\\
   $H = Museo.Indirizzo$\\
   $I = Quadro.Anno$\\
   $J = Quadro.Titolo$\\
  \end{flushleft}
  \end{multicols}

 \noindent(1) $\pi_{J, H, G}((\sigma_{F=``Toscana''}(MUSEO))\bowtie_{E=B}((\sigma_{D=``Pinturicchio''}(PITTORE))\bowtie_{A=C}(QUADRO)))$\\
 (2) $\pi_{H, G}(\sigma_{F=``Toscana''}(MUSEO)) -$\\
 $- \pi_{H, G}((\sigma_{F=``Toscana''}(MUSEO))\bowtie_{E=B}(\sigma_{I > 1499 \wedge I < 1600}(QUADRO)))$\\

  \subsubsection{Esercizio 2}
 Dati $R=ABCDEHI$ e $F=\{A\rightarrow BC, AB\rightarrow D, C\rightarrow ED, AD\rightarrow E\}$
 \begin{itemize}
  \item Mostrare che $AHI$ è una chiave di $R$;
  \item Sapendo che $AHI$ è l'unica  chiave di $R$, mostrare che $R$ non è in terza forma normale;
  \item Fornire una decomposizione $\rho$ di $R$ tale che:
   \begin{itemize}   
     \item ogni schema in $\rho$ è in terza forma normale
    \item $\rho$ preserva $F$
    \item $\rho$ ha un join senza perdita
    \end{itemize}
 \end{itemize}
 
 \noindent\textbf{\fontsize{14pt}{1em}Soluzione.}\\
 $AHI$ è chiave per $R$ $\Leftrightarrow AHI \rightarrow R\in F^+ \Leftrightarrow R \subseteq (AHI)^+_F$. Inoltre, la chiusura
 di ogni sottoinsieme di $AHI$ non contiene $R$.
 Calcoliamo le chiusure e verifichiamo le condizioni necessarie.\\\\
 $(AHI)^+_F = ABCDEHI \supseteq R$;\\
 $(AH)^+_F = ABCDEH \not\supseteq R$;\\
 $(AI)^+_F = IABCDE \not\supseteq R$;\\
 $(HI)^+_F = HI \not\supseteq R$;\\
 Ne tanto meno la chiusura dei singoli attributi contiene $R$. Quindi $AHI$ è chiave per $R$. $R$ non è in 3NF perché contiene
 la dipendenza $C\rightarrow ED$, la quale implica la presenza di $C \rightarrow E$ e $C\rightarrow D$ in $F^+$ e, tenuto conto
 della seconda ad esempio, $C$ non è superchiave e $D$ non è primo.\\

Per rispondere al terzo punto bisogna trovare la copertura minimale di $F$:
\begin{center}
 \begin{tabular}{l|l|l}
  $G$ & $G'$ & $G''$\\
  \hline
  $A\rightarrow B$ & $A\rightarrow B$ & $A\rightarrow B$ \\
  $A \rightarrow C$ & $A \rightarrow C$ & $A \rightarrow C$\\
  $AB \rightarrow D$ & $A \rightarrow D$ & \textbackslash \\ 
  $C \rightarrow E$ & $C \rightarrow E$ & $C \rightarrow E$\\
  $C \rightarrow D$ & $C \rightarrow D$ & $C \rightarrow D$\\
  $AD \rightarrow E$ & $A \rightarrow E$ & \textbackslash\\ 
 \end{tabular}
\end{center}
Quindi si esegue l'algoritmo 4.5 ed esce $\rho^1= \{HI, AB, AC, CE, CD\}$. La scomposizione cercata è
$\rho = \{AHI\} \cup \rho^1$.

\subsubsection{Esercizio 3}
\`E dato un file di 1.750.000 record. Ogni record occupa 130 byte, di cui 35 per la chiave. Un puntatore a blocco occupa 5 byte.
Un blocco di memoria contiene 2048 byte. Utilizziamo un indice ISAM, e supponiamo che ogni blocco sia per i dati che per l'indice 
sia utilizzato al massimo. 
\begin{enumerate}
 \item Quanti blocchi dobbiamo utilizzare per il file principale? 
 \item Quanti blocchi dobbiamo utilizzare per il file indice?
 \item Quale è il numero massimo di accessi per ricercare un record del file principale, utilizzando 
 la ricerca binaria sul file indice?
\end{enumerate}

\noindent\textbf{\fontsize{14pt}{1em}Soluzione.}\\
Come visto nel paragrafo Tecniche Risolutive, si calcola prima il numero di record per blocco. Il testo dice che 
ogni blocco è riempito al massimo. Applichiamo la formula:
\begin{center}
 $RecBlocco = \Bigl\lfloor \dfrac{2048-5}{130} \Bigr\rfloor = 15$.\\
\end{center}
Quindi calcoliamo il numero di blocchi nel file principale
\begin{center}
 $NumBlocchiFP = \Bigl\lceil \dfrac{1.750.000}{15} \Bigr\rceil = 116.667$.\\
\end{center}
Calcoliamo ora il numero di record in un blocco del file indice
\begin{center}
 $RecBloccoI = \Bigl\lfloor \dfrac{2048}{35+5} \Bigr\rfloor = 51$.\\
\end{center}
Il numero di blocchi nel file indice è dato dalla seguente formula:
\begin{center}
  $NumBlocchiFI= \Bigl\lceil \dfrac{116.667}{51} \Bigr\rceil = 2.288$.\\
\end{center}
Il numero massimo di accessi con la ricerca binaria sul file indice è quando l'algoritmo deve scorrere tutta l'altezza
dell'albero binario, quindi si ha $\lceil log_2(2.288)\rceil$ più 1 accesso al File Principale per un totale di 13 accessi.

\newpage
\subsection{Esame 1/07/2013}
  \subsubsection{Esercizio 1}
  Dato il seguente schema di una base di dati contenente dati su corsi universitari, aule e orario delle lezioni:
  \begin{center}
  AULA(Id, Nome, N-posti, Edificio)\\
  CORSO(Id, Titolo, Anno, Docente)\\ 
  ORARIO(Id-Aula, GiornoSettimana, Fascia-oraria, Id-Corso)\\
  \end{center}

  Esprimere in algebra relazionale le seguenti interrogazioni:
  \begin{enumerate}
   \item Per tutte le lezioni che si svolgono di venerdì in Aula Cabibbo si desidera conoscere il titolo del corso,
   il nome del docente e la fascia oraria.
   \item Titoli dei  corsi del terzo anno le cui lezioni non si svolgono il lunedì. 
  \end{enumerate}
  \noindent\textbf{\fontsize{14pt}{1em}Soluzione.}\\
  Per sintetizzare la scrittura, altrimenti troppo lunga, assegneremo ad ogni attributo che verrà usato
  nell'espressione una lettera.
  
  \begin{multicols}{3}
  \begin{flushleft}
   $A = Orario.Id-Corso$\\
   $B = Orario.Id-Aula$\\
   $C = Orario.GiornoSettimana$\\
   $D = Orario.Fascia-oraria$\\
   $E = Corso.Id$\\
   $F = Corso.Titolo$\\
   $G = Corso.Anno$\\
   $H = Corso.Docente$\\
   $I = Aula.Id$\\
   $J = Aula.Nome$\\
   $K = Aula.N-posti$\\
   $L = Aula.Edificio$\\
  \end{flushleft}
  \end{multicols}

 \noindent(1) $\pi_{F, H, D}((CORSO)\bowtie_{A=E}((\sigma_{J=``Cabibbo''}(AULA))\bowtie_{B=I}(\sigma_{C=``Venerdi''}(ORARIO))))$\\
 (2) $\pi_{F}(\sigma_{G=3}(CORSO)) -\pi_{F}((\sigma_{G=3}(CORSO))\bowtie_{E=A}(\sigma_{C=``Lunedi''}(ORARIO)))$\\

  \subsubsection{Esercizio 2}
 
 \begin{itemize}
  \item Dati $R=ABCDE$, $F=\{AB\rightarrow CD, CD\rightarrow E, E\rightarrow AB\}$ e $\rho_{ABCD, CDE}$, decidere se $\rho$
  preserva $F$.
  \item Dati lo schema di relazione $R=ABCDE$, l'insieme di dipendenze funzionali $F=\{AE\rightarrow C, D\rightarrow CE, B\rightarrow AE\}$
  e la decomposizione $\rho =\{ACD, BD, BCE\}$ decidere se $\rho$ ha un join senza perdita. 
 \end{itemize}
 
 \noindent\textbf{\fontsize{14pt}{1em}Soluzione.}\\
 Per rispondere al primo punto utilizziamo l'Algoritmo 4.2 e 4.3. Sappiamo che se gli attributi di una dipendenza sono presenti
 tutti in una relazione della scoposizione, tale dipendenza è sicuramente in $G^+$.\\
 $AB\rightarrow CD \in G^+$? Si\\
 $CD\rightarrow E \in G^+$? Si\\
 $E\rightarrow AB \in G^+$? Da verificare con l'algoritmo\\
 
 \noindent Calcoliamo $E^+_G$\\
 $Z^{(0)}=E$\\
 $S^{(0)}=(E\cap CDE)^+_F \cap CDE= CDE$\\
 $Z^{(1)}=CDE$\\
 $S^{(1)}=CDE \cup (CDE \cap ABCD)^+_F \cap ABCD= ABCDE$\\
 $Z^{(2)}=ABCDE$\\
 $S^{(2)}=ABCDE$\\
 
 \noindent Dato che $AB \subseteq Z^{(2)} = ABCDE$, ne segue che $E\rightarrow AB \in G^+$ e quindi $\rho$ preserva $F$.\\
 
\noindent Per rispondere al secondo punto bisogna usare l'algoritmo 4.4, quindi costruiamo la tabella ed eseguiamo l'algoritmo:

\begin{multicols}{2}
   \begin{center}
  \begin{tabular}{c|c|c|c|c|c}
    & \textbf{A} & \textbf{B} &\textbf{C} &\textbf{D}     &\textbf{E}\\
   \hline
   \textbf{ACD} & $a_1$       & $b_{1,2}$ & $a_3$ & $a_4$ & $b_{1,5}$ \\
   \hline
   \textbf{BD}  &$b_{2,1}$    & $a_2$     & $b_{2,3}$ & $a_4$ & $b_{2,5}$ \\
   \hline
   \textbf{BCE} & $b_{3,1}$   & $a_2$  & $a_3$ & $b_{3,4}$ & $a_5$\\
  \end{tabular}
 \end{center}
 
  \begin{center}
  \begin{tabular}{l|c}
   & $I_1$\\
   \hline
   $AE\rightarrow C$ & $\cdot$\\
   $D\rightarrow CE$ & $\checkmark$\\
   $B \rightarrow AE$ & $\checkmark$\\
  \end{tabular}
 \end{center}
 \end{multicols}
 
\begin{multicols}{2}
   \begin{center}
  \begin{tabular}{c|c|c|c|c|c}
    & \textbf{A} & \textbf{B} &\textbf{C} &\textbf{D}     &\textbf{E}\\
   \hline
   \textbf{ACD} & $a_1$       & $b_{1,2}$ & $a_3$ & $a_4$ & $b_{1,5}$ \\
   \hline
   \textbf{BD}  & $\mathbf{b_{3,1}}$  & $a_2$ & $\mathbf{a_3}$ & $a_4$ & $\mathbf{a_5}$ \\
   \hline
   \textbf{BCE} & $b_{3,1}$   & $a_2$  & $a_3$ & $b_{3,4}$ & $a_5$\\
  \end{tabular}
 \end{center}
 
  \begin{center}
  \begin{tabular}{l|c|c}
   & $I_1$ & $I_2$\\
   \hline
   $AE\rightarrow C$ & $\cdot$ & $\cdot$\\
   $D\rightarrow CE$& $\checkmark$& $\checkmark$\\
   $B \rightarrow AE$ & $\checkmark$& $\cdot$\\
  \end{tabular}
 \end{center}
 \end{multicols}

 \begin{multicols}{2}
   \begin{center}
  \begin{tabular}{c|c|c|c|c|c}
    & \textbf{A} & \textbf{B} &\textbf{C} &\textbf{D} &\textbf{E}\\
   \hline
   \textbf{ACD} & $a_1$  & $b_{1,2}$ & $a_3$ & $a_4$ & $\mathbf{a_5}$ \\
   \hline
   \textbf{BD}  & $b_{3,1}$ & $a_2$ & $a_3$ & $a_4$ & $a_5$ \\
   \hline
   \textbf{BCE} & $b_{3,1}$   & $a_2$  & $a_3$ & $b_{3,4}$ & $a_5$\\
  \end{tabular}
 \end{center}
 
  \begin{center}
  \begin{tabular}{l|c|c|c}
   & $I_1$ & $I_2$ & $I_3$\\
   \hline
   $AE\rightarrow C$ & $\cdot$ & $\cdot$ & $\cdot$\\
   $D\rightarrow CE$ & $\checkmark$ & $\checkmark$ & $\cdot$\\
   $B \rightarrow AE$ & $\checkmark$ & $\cdot$ & $\cdot$\\
  \end{tabular}
 \end{center}
 \end{multicols}
 
Alla terza iterazione non ci sono più dipendenze non rispettate dall'istanza di $R$, ma non c'è una riga con tutte ``a''.
L'algoritmo termina qui, dichiarando che $\rho$ ha una perdita nel Join.
\subsubsection{Esercizio 3}
Abbiamo un file di 353.000 record. Ogni record occupa 47 byte di cui 10 per la chiave. Ogni blocco contiene 2048 byte. 
Un puntatore a blocco occupa 4 byte. Usiamo una organizzazione B-tree riempiendo al minimo sia i blocchi del file 
principale che quelli del file indice.

\begin{enumerate}
 \item Quanti blocchi dobbiamo utilizzare per il file principale? 
 \item Quanti blocchi dobbiamo utilizzare per il file indice?
 \item Qual è il costo di una ricerca?
\end{enumerate}

\noindent\textbf{\fontsize{14pt}{1em}Soluzione.}\\
Come visto nel paragrafo Tecniche Risolutive, si calcola prima il numero di record per blocco.
\begin{center}
 $RecBlocco = \Bigl\lceil \dfrac{2048}{2\cdot 47} \Bigr\rceil = 22$.\\
\end{center}
Quindi calcoliamo il numero di blocchi nel file principale
\begin{center}
 $NumBlocchiFP = \Bigl\lceil \dfrac{353.000}{22} \Bigr\rceil = 16.046$.\\
\end{center}
Calcoliamo ora il numero di record in un blocco del file indice
\begin{center}
 $RecBloccoI = \Bigl\lceil \dfrac{1024-4}{14} \Bigr\rceil + 1 = 74$.\\
\end{center}
Il numero di blocchi nel file indice è dato dalla somma dei seguenti valori:
\begin{center}
 Blocchi al livello I $= \Bigl\lceil \frac{16.046}{74} \Bigr\rceil = 217$.\\

 Blocchi al livello II $= \Bigl\lceil \frac{217}{74} \Bigr\rceil = 3$.\\

 Blocchi al livello III $= \Bigl\lceil \frac{3}{74} \Bigr\rceil = 1$.\\
 
 Totale = 221 blocchi.
\end{center}

Il costo della ricerca è 4 accessi.

\newpage
\subsection{Esame 10/09/2013}
  \subsubsection{Esercizio 1}
  Dato il seguente schema di una base di dati contenente dati relativi a musei:
  \begin{center}
  MUSEO(CodM, Nome, Indirizzo, Regione)\\
  PITTORE(CodP, Nome, Cognome, Soprannome, DataNascita, DataMorte)\\
  QUADRO(CodQ, Titolo, Autore, Anno, Museo)\\
  \end{center}
  NOTE: 
  \begin{itemize}
   \item CodM, CodP, CodQ sono gli ID delle rispettive relazioni
   \item L'attributo Autore nella tabella QUADRO è il codice dell'autore del quadro
   \item L'attributo Museo nella tabella QUADRO è il codice del museo in cui il quadro è conservato
   \item L'attributo Anno nella tabella QUADRO è l'anno di realizzazione dell'opera 
  \end{itemize}

 Esprimere in algebra relazionale le seguenti interrogazioni:
 \begin{enumerate}
  \item Informazioni (titolo del quadro e le informazioni anagrafiche del suo autore) sui quadri conservati alla Galleria Borghese.
  \item In quali musei di Roma non è conservato alcun quadro del Caravaggio? Restituire come risultato nome e indirizzo del museo.
 \end{enumerate}

  \noindent\textbf{\fontsize{14pt}{1em}Soluzione.}\\
  Per sintetizzare la scrittura, altrimenti troppo lunga, assegneremo ad ogni attributo che verrà usato
  nell'espressione una lettera.
  
  \begin{multicols}{3}
  \begin{flushleft}
   $A = Museo.CodM$\\
   $B = Museo.Nome$\\
   $C = Museo.Indirizzo$\\
   $D = Museo.Regione$\\
   $E = Pittore.CodP$\\
   $F = Pittore.Nome$\\
   $G = Pittore.Cognome$\\
   $H = Pittore.Soprannome$\\
   $I = Pittore.DataNascita$\\
   $J = Pittore.DataMorte$\\
   $K = Quadro.CodQ$\\
   $L = Quadro.Titolo$\\
   $M = Quadro.Autore$\\
   $N = Quadro.Museo$\\
  \end{flushleft}
  \end{multicols}

 \noindent(1) $\pi_{L, F, G, H, I, J}((PITTORE)\bowtie_{E=M}((\sigma_{B=``Galleria\ Borghese''}(MUSEO))\bowtie_{A=N}(QUADRO)))$\\
 (2) $\pi_{B,C}(\sigma_{D=``Roma''}(MUSEO)) - $\\ 
 $-\pi_{B,C}((\sigma_{D=``Roma''}(MUSEO))\bowtie_{A=N}((\sigma_{H=``Caravaggio''}(PITTORE))\bowtie_{E=M}(QUADRO)))$\\

 \subsubsection{Esercizio 2}
\begin{itemize}
  \item Dato lo schema di relazione $R = ABCDEHI$ e il seguente insieme di dipendenze funzionali $F=\{AB\rightarrow CD, 
  D\rightarrow EH, DH\rightarrow I, I\rightarrow AB\}$ dire se la decomposizione $\rho =\{ABCD, DEH, DHI\}$ preserva $F$.

  \item Dato lo schema di relazione $R = ABCDE$ e il seguente insieme di dipendenze funzionali $F=\{E\rightarrow AB, D\rightarrow E,
  BC\rightarrow D, B\rightarrow C\}$ dire se la decomposizione $\rho =\{AB, BD, ACD, DE\}$ ha un join senza perdita.
 \end{itemize}
 
 \noindent\textbf{\fontsize{14pt}{1em}Soluzione.}\\
 Per rispondere al primo punto utilizziamo l'Algoritmo 4.2 e 4.3. Sappiamo che se gli attributi di una dipendenza sono presenti
 tutti in una relazione della scoposizione, tale dipendenza è sicuramente in $G^+$.\\
 $AB\rightarrow CD \in G^+$? Si\\
 $D\rightarrow EH \in G^+$? Si\\
 $BC\rightarrow D \in G^+$? Si\\
 $I\rightarrow AB \in G^+$? Da verificare con l'algoritmo\\
 
 \noindent Calcoliamo $E^+_G$\\
 $Z^{(0)}=I$\\
 $S^{(0)}=(I\cap DHI)^+_F \cap DHI= DHI$\\
 $Z^{(1)}=DHI$\\
 $S^{(1)}=DHI \cup [(DHI \cap ABCD)^+_F \cap ABCD] \cup [(DHI \cap DEH)^+_F \cap DEH] = ABCDEHI$\\
 $Z^{(2)}=ABCDEHI$\\
 $S^{(2)}=ABCDEHI$\\
 
 \noindent Dato che $AB \subseteq Z^{(2)} = ABCDEHI$, ne segue che $I\rightarrow AB \in G^+$ e quindi $\rho$ preserva $F$.\\
 
\noindent Per rispondere al secondo punto bisogna usare l'algoritmo 4.4, quindi costruiamo la tabella ed eseguiamo l'algoritmo:

\begin{multicols}{2}
   \begin{center}
  \begin{tabular}{c|c|c|c|c|c}
    & \textbf{A} & \textbf{B} &\textbf{C} &\textbf{D}     &\textbf{E}\\
   \hline
   \textbf{AB} & $a_1$ & $a_2$ & $b_{1,3}$ & $b_{1,4}$ & $b_{1,5}$ \\
   \hline
   \textbf{BD}  &$b_{2,1}$ & $a_2$  & $b_{2,3}$ & $a_4$ & $b_{2,5}$ \\
   \hline
   \textbf{ACD} & $a_1$ & $b_{3,2}$  & $a_3$ & $a_4$ & $b_{3,5}$\\
    \hline
   \textbf{DE} & $b_{4,1}$   & $b_{4,2}$  & $b_{4,3}$ & $a_4$ & $a_5$\\
  \end{tabular}
 \end{center}
 
  \begin{center}
  \begin{tabular}{l|c}
   & $I_1$\\
   \hline
   $E\rightarrow AB$ & $\cdot$ \\
   $D\rightarrow E$ & $\checkmark$ \\
   $BC\rightarrow D$ & $\cdot$ \\
   $B\rightarrow C$ & $\checkmark$ \\
   \end{tabular}
 \end{center}
 \end{multicols}
 
 \begin{multicols}{2}
   \begin{center}
  \begin{tabular}{c|c|c|c|c|c}
    & \textbf{A} & \textbf{B} &\textbf{C} &\textbf{D}     &\textbf{E}\\
   \hline
   \textbf{AB} & $a_1$ & $a_2$ & $\mathbf{b_{2,3}}$ & $b_{1,4}$ & $b_{1,5}$ \\
   \hline
   \textbf{BD}  &$b_{2,1}$ & $a_2$  & $b_{2,3}$ & $a_4$ & $\mathbf{a_5}$ \\
   \hline
   \textbf{ACD} & $a_1$ & $b_{3,2}$  & $a_3$ & $a_4$ & $\mathbf{a_5}$\\
    \hline
   \textbf{DE} & $b_{4,1}$   & $b_{4,2}$  & $b_{4,3}$ & $a_4$ & $a_5$\\
  \end{tabular}
 \end{center}
 
  \begin{center}
  \begin{tabular}{l|c|c}
   & $I_1$ & $I_2$\\
   \hline
   $E\rightarrow AB$ & $\cdot$ & $\checkmark$ \\
   $D\rightarrow E$ & $\checkmark$ & $\cdot$ \\
   $BC\rightarrow D$ & $\cdot$ & $\checkmark$ \\
   $B\rightarrow C$ & $\checkmark$ & $\cdot$ \\
   \end{tabular}
 \end{center}
 \end{multicols}
 Da notare che se si sceglie bene l'ordine delle tuple alle quali applicare l'algoritmo, è possibile risparmiarsi qualche iterazione.
 Infatti scegliendo, ad esempio, per prima $t_3[E]$ e $t_4[E]$ e poi $t_2[E]$ e $t_3[E]$, otteniamo 
 le colonne $A$ e $B$ riempite con sole ``$a$'' in una sola iterazione. 
  \begin{multicols}{2}
   \begin{center}
  \begin{tabular}{c|c|c|c|c|c}
    & \textbf{A} & \textbf{B} &\textbf{C} &\textbf{D}     &\textbf{E}\\
   \hline
   \textbf{AB} & $a_1$ & $a_2$ & $b_{2,3}$ & $\mathbf{a_4}$ & $b_{1,5}$ \\
   \hline
   \textbf{BD}  &$\mathbf{a_1}$ & $a_2$  & $b_{2,3}$ & $a_4$ & $a_5$ \\
   \hline
   \textbf{ACD} & $a_1$ & $\mathbf{a_2}$  & $a_3$ & $a_4$ & $a_5$\\
    \hline
   \textbf{DE} & $\mathbf{a_1}$ & $\mathbf{a_2}$  & $b_{4,3}$ & $a_4$ & $a_5$\\
  \end{tabular}
 \end{center}
 
  \begin{center}
  \begin{tabular}{l|c|c|c}
   & $I_1$ & $I_2$ & $I_3$\\
   \hline
   $E\rightarrow AB$ & $\cdot$ & $\checkmark$ \\
   $D\rightarrow E$ & $\checkmark$ & $\cdot$ \\
   $BC\rightarrow D$ & $\cdot$ & $\checkmark$ \\
   $B\rightarrow C$ & $\checkmark$ & $\cdot$ \\
   \end{tabular}
 \end{center}
 \end{multicols}
A questo punto ci accorgiamo di aver ottenuto una riga con tutte ``a'', quindi l'algoritmo termina. La decomposizione $\rho$ 
ha un Join senza perdita.

 
\subsubsection{Esercizio 3}
\`E dato un file di 1.750.000 record. Ogni record occupa 130 byte. Un puntatore a blocco occupa 5 byte. 
Un blocco di memoria contiene 2048 byte. Il file ha un’organizzazione hash con 300 bucket.
\begin{enumerate}
 \item Quanti blocchi di memoria occupa il file?
 \item Quale è il numero medio di accessi per ricercare un record del file?
\end{enumerate}
\begin{multicols}{2}
Calcoliamo innanzitutto il numero di record per blocco richiesto per la directory; in questo
caso i record contengono solo i puntatori al primo blocco di un bucket.
\begin{center}
 $puntatori \times blocco = \Bigl\lfloor \dfrac{2048}{5} \Bigr\rfloor = 409$
\end{center}
quindi i blocchi richiesti dalla directory sono
\begin{center}
 $BlocchiDir = \Bigl\lceil \dfrac{300}{409} \Bigr\rfloor = 1$
\end{center}
Passiamo al file principale, diviso in bucket. Calcoliamo il numero di record per blocco
\begin{center}
 $\Bigl\lfloor \dfrac{2048-5}{130} \Bigr\rfloor = 15$
\end{center}
I record totali devono essere ripartiti uniformemente nei bucket
\begin{center}
 $record \times bucket = \Bigl\lceil \dfrac{1.750.000}{300} \Bigr\rceil = 5834$
\end{center}
Ora il numero totale di blocchi nel file principale è dato dal numero di blocchi in un bucket
moltiplicato per il numero di bucket.
\begin{center}
 $BlocchiFP = \Bigl\lceil \dfrac{5834}{15} \Bigr\rceil \cdot 300 = 116.700$
\end{center}
Quindi in totale il file occupa 116.700 + 1 (quello della directory) blocchi. Il costo medio di 
una ricerca è dato da
\begin{center}
 $\Bigl\lceil \Bigl\lceil \dfrac{5834}{15} \Bigr\rceil \cdot \dfrac{1}{2} \Bigr\rceil$
\end{center}
visto che si cerca dentro un solo bucket ed essendo il costo medio si suppone che il record
cercato sia a metà bucket.
\end{multicols}








\newpage
\subsection{Esame 12/11/2013}
  \subsubsection{Esercizio 1}
  Dato il seguente schema di una base di dati contenente dati relativi a musei:
  \begin{center}
    MUSEO (CodM, Nome, Città)
    PITTORE (CodP, Nome, Cognome, Soprannome, DataNascita, DataMorte)
    QUADRO (CodQ, Titolo, Autore, Anno, Museo)
  \end{center}
  NOTE: 
  \begin{itemize}
   \item CodM, CodP, CodQ sono gli ID delle rispettive relazioni
   \item L'attributo Autore nella tabella QUADRO è il codice dell'autore del quadro
   \item L'attributo Museo nella tabella QUADRO è il codice del museo in cui il quadro è conservato
  \end{itemize}
 Esprimere in algebra relazionale le seguenti interrogazioni:
 \begin{enumerate}
  \item Per ogni quadro conservato in un museo di Roma si desidera conoscere: titolo del quadro 
  e nome e cognome dell’autore e il nome del museo in cui è conservato.
  \item Dati dei musei di Roma in cui non sono conservati quadri di autori morti dopo il 1900.
 \end{enumerate}

  \noindent\textbf{\fontsize{14pt}{1em}Soluzione.}\\
  Per sintetizzare la scrittura, altrimenti troppo lunga, assegneremo ad ogni attributo che verrà usato
  nell'espressione una lettera.
  
  \begin{multicols}{3}
  \begin{flushleft}
   $A = Museo.CodM$\\
   $B = Museo.Nome$\\
   $C = Museo.Citt\grave{a}$\\
   $D = Pittore.CodP$\\
   $E = Pittore.Nome$\\
   $F = Pittore.Cognome$\\
   $G = Pittore.Soprannome$\\
   $H = Pittore.DataNascita$\\
   $I = Pittore.DataMorte$\\
   $J = Quadro.CodQ$\\
   $K = Quadro.Titolo$\\
   $L = Quadro.Autore$\\
   $M = Quadro.Museo$\\
  \end{flushleft}
  \end{multicols}

 \noindent(1) $\pi_{K, E, F, B}((PITTORI)\bowtie_{D=L}((\sigma_{C=``Roma''}(MUSEO))\bowtie_{A=M}(QUADRO)))$\\
 (2) $\pi_{A,B,C}((\sigma_{C=``Roma''}(MUSEO))) - $\\ $ - \pi_{A,B,C}((\sigma_{C=``Roma''}(MUSEO))\bowtie_{A=M}((QUADRO)\bowtie_{L=D}(\sigma_{I>1900}(PITTORE))))$\\
  
  Nel punto (2) prendiamo prima tutti i musei di Roma che contengono opere di autori morti dopo il 1900, in seguito li 
  sottraiamo alla relazione contentente tutti i musei di Roma, dando cosi la relazione richiesta.
  \subsubsection{Esercizio 2}
   Dati $R=ABCDEH$ e $F=\{AB\rightarrow CD, B\rightarrow E, E\rightarrow D\}$

 \begin{enumerate}
  \item Mostrare che $ABH$ è una chiave di $R$
  \item Sapendo che $ABH$ è l’unica chiave di $R$, mostrare che $R$ non è in terza forma normale
  \item Trovare una decomposizione $\rho$ di $R$ tale che:
   \begin{itemize}
    \item ogni schema in $\rho$ è in terza forma normale
    \item $\rho$ preserva $F$
    \item $\rho$ ha un join senza perdita
   \end{itemize}
 \end{enumerate}

 \noindent\textbf{\fontsize{14pt}{1em}Soluzione.}\\
 Per rispondere al primo punto utilizziamo l'Algoritmo 4.2 e 4.3. Sappiamo che se gli attributi di una dipendenza sono presenti
 tutti in una relazione della scoposizione, tale dipendenza è sicuramente in $G^+$.\\
 
 \noindent$ABH$ è chiave $\Leftrightarrow R\subseteq (ABH)^+_F$ ed $R$ non è contenuto nella chiusura di nessun sottoinsieme di
 attributi di $ABH$.\\
 $(ABH)^+_F= ABHCDE \supseteq R$\\
 $(AB)^+_F = ABCDE \not\supseteq R$\\
 $(AH)^+_F = AH \not\supseteq R$\\
 $(BH)^+_F= BHED \not\supseteq R$\\
 ne tanto meno R sarà contenuto nelle chiusure dei singoli attributi. $R$ tuttavia non è in terza forma normale perché $F^+$ 
 contiene dipendenze come $B\rightarrow E$, dove $B$ non è superchiave e $E$ non è primo.\\
 
 \noindent Per trovare la decomposizione richiesta bisogna prima trovare la copertura minimale di $F$:\\
 
 \begin{tabular}{l|l|l}
 $G$ & $G'$ & $G''$\\
 \hline
 $AB \rightarrow C$ & $AB \rightarrow C$ & $AB \rightarrow C$\\
 $AB \rightarrow D$ & $B \rightarrow D$ & \textbackslash \\
 $B \rightarrow E$ & $B \rightarrow E$ & $B \rightarrow E$\\
 $E \rightarrow D$ & $E \rightarrow D$ & $E \rightarrow D$\\
 \end{tabular}\\
 
 \noindent Applicando l'Algoritmo 4.5 troviamo $\rho^1= \{H, ABC, BE, DE\}$, alla quale aggiungiamo la chiave di $R$
 per ottenere la scomposizione richiesta $\rho = \rho^1 \cup \{ABH\}$.
 
\subsubsection{Esercizio 3}
Abbiamo un file di 288.000 record. Ogni record occupa 49 byte di cui 10 per la chiave. Ogni blocco contiene 2048 byte.
Un puntatore a blocco occupa 4 byte. Usiamo una organizzazione ISAM riempiendo i blocchi del file principale all'$80\%$.
\begin{enumerate}
 \item  Quanti blocchi dobbiamo utilizzare per il file principale? 
 \item Quanti blocchi dobbiamo utilizzare per il file indice?
 \item Qual è il costo massimo per la ricerca di un record? 
\end{enumerate}

\noindent\textbf{\fontsize{14pt}{1em}Soluzione.}\\
Innanzitutto calcoliamo l'$80\%$ di 2048. $\lceil2048 \cdot 0,8\rceil = 1639$

Calcoliamo il numero di recod per blocco
\begin{center}
 $RecBlocco = \Bigl\lceil \dfrac{1639}{49} \Bigr\rceil = 34$.\\
\end{center}
Quindi calcoliamo il numero di blocchi nel file principale
\begin{center}
 $NumBlocchiFP = \Bigl\lceil \dfrac{288.000}{34} \Bigr\rceil = 8.471$.\\
\end{center}
Calcoliamo ora il numero di record in un blocco del file indice
\begin{center}
 $RecBloccoI = \Bigl\lceil \dfrac{1639}{14} \Bigr\rceil = 118$.\\
\end{center}
Il numero di blocchi nel file indice è dato dalla formula:
\begin{center}
 $\Bigl\lceil \dfrac{8.471}{118} \Bigr\rceil = 72$.
\end{center}
Il costo massimo per la ricerca è $\lceil log_2(72)\rceil + 1 = 8$
  
 





